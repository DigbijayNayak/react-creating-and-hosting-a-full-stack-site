# Connecting the Front End and Back End

## 1. The Axios library

- All right. So at this point we have both the front end and back end of our full stack blog application, mostly complete, at least complete enough to actually start bringing the two ends together. Now to get ourselves started here. What you're going to want to do is open up both the front end and back end in your IDE. I usually like to open these up inside the same window, but you can also open them up in separate windows.
- So what I'm going to do in order to open them up in the same window is just change directories out to the containing directory, and run code dot. And that will open up both the front and the backend folders inside the same IDE window. Which will make it pretty easy to work with as you'll see. All right, so we have the front end and back end now. And our next task is to connect these things, right.
- Essentially what we want to do, is have our front end make the same types of requests that we were making from postman, but obviously the front end is going to need to make those requests using code. Now, there are several ways to get the front end to do this, but the way that we're going to be doing it, is using a library called Axios.
- Now, Axios is an incredibly popular library for making network requests, and it can be installed into either front end or backend projects, and used to make any type of request to pretty much any URL. So we're going to be using this library in order to have our front end make requests to the back end. So this is sort of our front ends postman, if you will. All right.
- So first things first let's install the Axios library, and we're going to want to install that into our front end directories. So let's open up a terminal, and you're going to want to make sure that you're in the front end directory by saying CD my blog. And once you're there, we're going to install Axios by typing NPM, install, Axios and hitting enter. Okay. So that will install the Axios library for us. So now let's talk about how the Axios library is actually going to be used in our front end application. Okay. So I'm just going to open up the app dot JS file here.
- And I'm just going to use this as an example. I'll just scroll all the way down so that I can use this as a sort of whiteboard, if you will. So the Axios library, it's actually incredibly simple. All you have to do is import it and once you've imported it, you can make requests to any URL you want by calling Axios dot, and then the type of request you want to make. So if you want to make a get request, all you need to do is say Axios dot get. And then the argument that you're going to pass to this, is going to be the URL that you want to make this request to. So in our case, we'll want to make the request to HTTP, colon slash slash local host, 8,000.
- And let's say we want to load the article data for some article, we would say slash API, slash articles, slash, and then we'd have the article ID such as learn-react, all right? And that function, called in the way that we're calling it right here, will make a request to our server. And in order to get the response that our server sends back, all you need to do is say const response, equals await, Axios dot, get, all right.
- So most of these functions that Axios provides, like get or post, you can also do Axio dot post, or Axio dot put, these are all going to be asynchronous, which means that you'll need to use the await keyword with them. All right. And that will give you the response, the way that you can get the data that the response contains. Right? So if we said response dot JSON, for example on the server side, we could get that by saying const, data, equals response dot data.
- And that's really all there is to it. All right. Now, there are other things that we might want to do, like add data to the requests that we're sending from Axios, but that's something that we'll take a look at a little later when we get there. So that's the Axios library. And as I said, this is what we're going to be using to tie our front end and back end together. So let's just delete this code here. And the next thing that we're going to want to do is take a look at how to start loading some data into our components.

## 2. Adding React hooks

- All right, so now that we've installed the Axios library and we know the basic syntax that it uses, let's take a look at how to load data into our article page from the server. So, the first thing that we're going to want to do here is open up our article page. And this is where we're going to be writing most of our code for this video.
- So, our basic goal here with loading data is when we visit the article page, right, when one of our article pages is first displayed, we'll want that page to make a request to our server. And we'll want our server, obviously, to send back the number of upvotes and comments for that article, which our article page will then display.
- So, there's a few steps here. The first thing that we're going to need to do is actually load the data in the first place. And then we'll need to add a few more components and elements down here in our article page's JSX, you know and create components such as the comment form. So, the first thing that we're going to have to do here in order to be able to load data and use it, is we're going to have to add state to our component, right? Currently, none of our components really have any kind of memory.
- They're just returning some JSX depending on the props that we pass into them and the hooks that they happen to be using, such as this useParams hook here. All right, now the entire point of state in this context is to give us a place to store the response that we get back from the server.
- So, the first thing that we're going to have to do is import reacts useState hook. Now, if you've never used this hook before this is just the way that in modern react we add state to our components. All right, and if you've never used this useState hook before, this is just the way that we add state to function components in modern react.
- So we're going to say import useState from react, and then down here in our article page, what we're going to do is say, const articleInfo and setArticleInfo. There we go. Equals useState, and for the default value here, we're going to say upvotes: 0 and comments, empty string or empty array rather. Okay, so what we just did here is we added a state called articleInfo to our article page component.
- And what we're going to need to do now, is make a request to the server and basically just set our article info state using the setArticleInfo function to the data that we get back from the server. And that will replace this default value here that we passed to the useState function. All right. So, the way that we're going to actually load data is using another react hook.
- And this other react hook is going to be called useEffect. Now, the entire point of the use effect hook in case you're not familiar with it is to allow us to add logic into our components that will be executed outside of the normal component rendering, right? So, in other words, useEffect hooks are where we want to put most of our logic for doing things like loading data from a server.
- So, what we're going to do is right underneath where we define our state, we're going to say useEffect. And for now let's just simulate what this use effect thing will look like by calling setArticleInfo with some fake data. All right, so we'll say upvotes, and let's just say that we want to set upvotes to 3 and we'll set comments to just an empty array like we had before.
- All right, now what we just wrote here is a simulation for what we'll be doing when we actually get back data from the server, which we'll see how to do in just a minute. And it's going to enable us to take a look at a few more complicated aspects of using the use effect hook to load data. So, now that we have this article info what we're going to do is head down here to where we have our main JSX for our article page component.
- And all we're going to do is underneath the article title, we're going to add a paragraph tag that says, this article has, and then we're going to add the number of upvotes that the article has by saying, articleInfo.upvotes, and then after that, we'll say upvotes. And in fact, we'll even put the S inside parenthesis so that it will make it a little more grammatically correct. Great.
- So, let's try this thing out. What we're going to do, is just run our front end and we can do that by changing directories into our, my blog directory. If you're not there already and running npm run start. And this will of course open up our react app in our browser.
- And if we go to our article page now by clicking on articles up here and clicking on one of our articles from the list, sure enough, it'll say this article has three upvotes. Now, at this point, this data is not actually from the server, right? We just hard coded that in our useEffect hook but this is the basic setup and hooks that we're going to be using to actually start loading data from the server. So, that's the next thing we're going to do is add the Axios library to this component and start making requests.

## 3. Calling useEffect at the right time

- Okay. So we've added state and the use effect hook to our article page, and we've simulated data loading here. But before we move on to implementing the actual data fetching, right using Axios, there are two more caveats that we need to address. The first one is pretty subtle, but when it shows up, it really shows up. Okay. And if you're wondering what I mean by that and want to see it in action, let's say that for testing purposes, instead of just hard coding the number of up votes here inside our use effect hook, we generated a random number of up votes, between let's say one and 10.
- All right. So what that would look like, we would say up votes math dot ceiling, and then we would say math dot random and multiply that by 10. Right? So that's how you generate a number between one and 10, using JavaScripts math dot random, in case you weren't aware of that. All right. So after making that change, what you're going to see if you go back to your browser, is that this up votes value is updating continuously, and it's just kind of going crazy right? Now, the reason that this is happening, is that the use effect hook runs not only when the component first mounts, right when the component is first added to the page, but it also runs whenever the component updates.
- And since we're updating the component from inside the use effect hook, using a random number, which is constantly going to give a different value our component is currently getting caught in an infinite loop. Now there's an easy way to prevent this, and that's by simply adding an empty array, as the second argument that we pass to use effect. And we'll see why this helps in a second, but first of all let's just save the file and go back and take a look, and sure enough we'll see that that's stopped the infinite loop and we can just refresh the page, and we'll see that that up votes number updates automatically.
- Okay. So let's go back and take a look at this empty array thing. The reason that this empty array thing works, is because basically what the use effect hook does, is whenever any of the values that are in this array, which currently is nothing, changes, the use effect hook will execute the logic in this callback function that we pass as the first argument.
- All right. So if we were to put this use effect hook underneath article ID, and pass article ID as a member of this array, then basically what this would do, is whenever the article ID changes, the use effect took would call this callback function that we passed as the first argument. All right.
- So basically by passing an empty array to use effect, we're basically telling it that we only want it to call this function that we're passing, when the component is first mounted, right? When the component is first added to the Dom. So that's actually what we're going to want most of the time when we're loading data from the serve, is for this use effect hook logic to only be called when the component is first mounted, because otherwise we would just be making requests to the server every single time the component changed. And that's obviously not what we want, so that's why we pass the empty array here.

## 4. Adding data loading to page components

- All right. So now that we're sure that our use effect hook logic is getting called at the right time, all we really have to do is, instead of setting our article info state to fake random data as we've been doing, we just need to load this data from the server and call set article info with the response that we get from the server instead. 
- So the first thing that we're going to want to do here, of course, is import the axios package. And to do that, we just need to say import axios from axios and then down here, inside use effect, what we're going to do is use the axios.get function to make a get request to the server endpoint that will give us back all of the info about the article. 
- So what that's going to look like we're going to say const response equals await axios.get and we're going to put in the URL of our server, which is going to be http://localhost:8000/api/articles, and then we're going to add the article ID here. Actually, what we're going to do is just convert these single quotes to backticks and insert the article name here. So we'll just say article ID and that means that we need to actually put the article ID above our use effect hook like so so that we have access to it inside of here. All right. 
- So that's how we make that request and that's really all we need to do. So once we get the response back, we're going to say const article info equals response.data, right? Remember that we said that's where the data that was included in the response is going to be and now, we just need to say set article info to article info. And actually, just to be clear here, so that we don't get mixed up with this article info and the article info state, let's call this variable new article info and then we'll say set article info to new article info. Okay. 
- And that's really all we need to do there. However, there are a few changes that we'll have to make. The first thing is since we're using the await keyword inside this use effect callback, you might imagine that we're going to need to add the async keyword to the use effect function. All right. 
- However, if we try and run our code now, what you're going to see if we go back to our browser and hit refresh is that nothing's showing up. Now, if you open the inspector window by right clicking and clicking on inspect and then going to the console, what you're going to see is this nasty looking series of errors that basically mean that you're not allowed to pass an asynchronous function as the first argument to use effect, all right? So what we have to actually do instead is remove the async keyword from this callback function and actually create an internal asynchronous function inside this function. 
- You'll see what this looks like in just a minute. We'll say const load article info equals and then this is just going to be an asynchronous function like so and we'll put all of our logic inside of there. And then we just need to call this load article info function after we define it. All right. And that will basically execute all of the logic inside of here. 
- That's just a little workaround that we have to do whenever we want asynchronous logic inside a use effect hook. So if we go back now, what we're going to see is that all of the elements in our app are showing up, which is good. However, you're going to see that the upvotes number is zero. Now, assuming that you've tested out your upvote endpoint, zero is not actually the right number which means that something is going wrong when we're trying to load that data. And if you open up your inspector window again and go to the console, you'll see what that is. And you may have to refresh to get rid of all the old errors, but sure enough, what we're going to see is that we're getting an error that says connection refused. 
- Now, the reason for this error is quite simply because we don't have the server running in the background. So if you ever see this error, you know why it's happening. It's just because you forgot to run the server. So let's go back here and we're going to open up our server in a new terminal. You'll want to leave the front end running. So we'll open up a new terminal and say my blog backend and then inside here, we'll run our server with npm run dev. 
- And now, let's go back to our browser and try and refresh this again. All right, we'll hit the refresh button and we're going to see that the upvotes is still at zero. So what you're going to see here is that we're running into a new error and if we go to the console, sure enough, what you'll see is an incredibly common error for beginners in full stack development to see and that is the error that your request has been blocked by a CORS policy, access control allow origin, blah blah blah. 
- Chances are you're going to see this all over the place as you start working with more full stack projects, but basically, all that it means is that **our front end and back end are running on different origins, right? In this case, on different ports. And therefore, they're not allowed to talk to each other.**
-  So in order to fix this error, the simplest way to do it is to just go into our front end, my blog folder, open up the front end package.json and we're going to add another value to this, which is going to be proxy, and the value for this is going to be the URL for our server, all right? So we'll say http://localhost:8000/ and add an extra slash at the end there. And basically, what this is going to do is it's going to make the front and the back end think that they're running on the same origin, which will get rid of those errors that we were seeing. Okay. 
   - package.json
        ```js
        "proxy": "http://localhost:8000/",
        ```
-  So let's close this and we're actually going to have to restart our front end. So let's just open this up and stop it and we'll run it again. And one more thing that we have to do is now that we have that proxy set up, we no longer have to specify the entire URL when we make requests with axios, right? We can just start after that local host 8,000 thing. So if we just change this now to **/api/articles/articleid** and go back to our browser, we should see now, these are all old errors by the way, we should see now that if we refresh the page, the article has three upvotes displayed, right, which is the correct number. And if we go take a look at some other articles, we'll see different numbers for those. 
-  Chances are these are both going to be zero because I don't think I ever tested either of these, but the takeaway here is that we're now successfully loading this article info from the server, which is great because we can now use this as a template to make other types of requests such as when we want to add an upvote to an article or add a comment to an article.

## 5. Displaying comments

## 6. Creating an upvote button

## 7. Creating an add comment form
