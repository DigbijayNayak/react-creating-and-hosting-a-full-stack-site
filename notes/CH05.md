# Adding User Authentication with Firebase Auth

## 1 Why Firebase Auth?

- All right, so now that we've added MongoDB to our full stack application and we have pretty much our full front end and backend completed, the next thing that we're going to do is see how to add basic user authentication to our app. Now, adding user authentication from scratch is something that can be kind of difficult. And I actually have a course on that as well, if you want to check that out.
- So what we're going to be doing here is using a tool base called Firebase Auth or Firebase Authentication to make the job of adding Auth to our app much easier. Now, Firebase Authentication, basically what it does is it takes care of storing all of our users' information and passwords in a very secure manner for us, right. We can't even see our users' passwords. So basically this allows us to sort of piggyback off of Google's security practices, which I can almost guarantee are going to be much more strict than yours.
- Okay, so what we're going to be seeing how to do is create a Firebase Auth project and add a few users to it. And we're also going to see how to enable different sign-in methods, such as email and password sign-in. And then of course, we're going to see how to integrate all of this into our React app and also into our Node.js backend. So that's Firebase Auth, let's jump right in and get started.

## 2 Creating a Firebase project

- All right. So now that we've learned a little bit about what Firebase off is and why it can be helpful for us, the first thing that we're going to do here is we're going to set up a Firebase project so that we'll be able to link this project to our front and back ends as you'll see how to do later on. So what you're going to want to do is go to **console.firebase.google.com** and if you don't already have a Google account you're going to need to create one first of all. And once you've done that you might need to do some additional pieces of setup.
- Google will basically walk you through all of that just by going to this URL here. But anyway, after you've done all that setup what you should be able to do is see this screen here. And what we're going to want to do is add a new project. So we'll just click on this button here that says, add project. And your screen here might look a little bit different than mine, just because I have a lot of projects already on Firebase and you probably won't at this point.
- So let's just click on this add project button and what this is going to do is ask us for a few different pieces of information about our project. So the first one it's going to ask us is for a project name and you can really call this whatever you want, as long as it doesn't conflict with another project that you have. But in our case, let's just call it My React Blog. And then down here, what you're going to see is that Firebase automatically generates a random ID that incorporates this name into it.
- All right, and you can actually edit that as well but this does have to be unique across all of the projects on Firebase. So anyway, once we've typed that in, we're going to click the continue button and this is going to ask us if we want Google analytics enabled for our project. Now Google analytics is a very useful tool, but for now just to keep things simple and because we're not going to be talking about it at all, we're going to turn that off. And then we'll click on create project and we're going to see this little loading spinner while Firebase creates our project for us. And this should only take a few seconds here.
- Once it's done, we're going to see this little continue button and we'll just click on that. And that will take us to the console for our project. Now there's obviously a lot of stuff in this console here but don't worry too much about it because the only thing that we're really going to be using is this authentication thing over here. So what we're going to do is just click on authentication and that's going to bring us to the authentication console where we're going to click this get started button which should enable Firebase authentication for our project.
- Now in Firebase off, Firebase off provides a lot of different ways for us to allow users to authenticate in our applications, such as with their Google account, with their game center account, Microsoft account, et cetera. There's lots of options here, but for now, just to keep things simple, what we're going to do is use email password authentication.
- So what you're going to want to do is click on this under native providers. And that'll bring up this little window here that has different types of email password authentication that are available to us. And we're only going to enable this first one up here which is just basic email password authentication. So let's click on enable here and click save. And now we've turned on email password authentication for our project. Okay.
- So the next thing that we're going to want to do is go into this user's tab inside Firebase off and we're going to create a test user that we can use to actually log into our application once we add this to our front end react app. So what you're going to want to do is click add user and that's going to come up with a little modal window here that asks us for our email and password. And these don't have to actually be a real email and password.
- So I'm just going to enter in shaun@gmail.com and the password here, I'm just going to do Abc123 and we'll click add user. And that will create a new user for us. Now, remember what that password is because you're going to need it to log in later when we actually add Firebase off to our react app. But for now that should be all the basic setup that we have to do in order to get our Firebase project created and get Firebase off, up and running.

## 3 Adding Firebase Auth to React

- All right, so now that we have a Firebase project created, the next thing that we're going to want to do is actually connect this project to our React application, and once we've done that we'll be able to actually use Firebase to log in users and create new user accounts. All right, so what we're going to do is we're going to go back to the main console for our project that we created, and you can do that just by clicking on project overview here.
- And then, in the middle of this console what you're going to see is this message that says, get started by adding Firebase to your app, and down here, underneath that, it's got a few different options. Now, the option that we want to select here is web because, obviously, the app that we're going to add this to is a web application. Now, if we were creating an iOS app or an Android app or even a game using Unity or an app using Flutter, we would select one of these other options, but since we're working with React, we're going to select web.
- Now, if you click on this button, the next thing that it's going to ask you for is an app nickname. Now, this is really just an indicator to remind you what app this represents. So, you can literally call this anything. I'm just going to call it, React front end, all right? And once we've done that, we're going to leave this checkbox for Firebase hosting unchecked.
- We're going to be using a different Google product to host our app and let's click on register app. Okay, so once we've done that the next thing that it's going to do is it's going to spit out all of this code that we can copy and paste into our React app in order to have our app automatically connect to the Firebase project that we created. So, what we're going to want to do is follow the two steps that it has.
- The first one here is installing the Firebase package into our React app, which we'll do, and the second step here is copying and pasting some configuration code into our react app. So, first things first, let's install Firebase into our React app. What you're going to want to do is open up your full stack project and open up a terminal as well and go into the front end of that project by saying CD my blog, and once we've done that, we're going to install the Firebase NPM package by saying NPM install Firebase, okay? And once we hit enter, that will install the Firebase package for us.
- So, the next thing that we're going to want to do is copy and paste this code that Firebase gave us into our project. Now, you might be wondering where this code goes, and the answer to that is that it goes into the entry point of our React application. So, if you open up My Blog and go into source, the entry point for React app, right, the file that contains the most important code in our React app that starts off the entire rendering process is inside index dot JS.
- So, let's open up that file, and what we're going to do is above where we actually say cons root equals, blah, blah, blah, and then, say, root dot render, we're going to paste all of that code that we just copied from Firebase, and you can remove the comments if you want, although, they do contain valuable information in case you're wondering exactly what it is that we're doing here, but just to be clean, I'm going to remove all of those comments, and that's basically all we need to do to connect our React app to Firebase.
- So, let's talk a little bit about what's going on here exactly. What we're doing is we're importing this initialized app function from the Firebase package that we just installed, and all that that does is it takes this big Firebase config object that basically just contains several different IDs and public keys that our React application can use to connect to the project that we just created, right? So, there's just lots of different things in here.
- Don't worry too much about what each of these does exactly. But another thing that I wanted to point out too is these are all public keys. So, it's perfectly fine to commit these to GitHub. Whereas if these were private keys, as we'll see later on with our back end, you would not want to have these in a publicly accessible Git repo. All right, so now that we've done that and we've initialized our app with that configuration object, our React app should be all set to connect to our Firebase project, and one way that we can verify this, of course, is just by trying to run our front end and making sure that it works.
- So, let's say NPM run start, and if we hit enter, we're probably going to see an error saying that the front end can't proxy to local host 8000, but that's just because we don't have the back end running. What we're looking for are some more conspicuous errors about Firebase, specifically, and since we don't see any of those, it means that our app is correctly connecting to Firebase.
- So, before we move on, what I want to do is just sort of set the stage for a few more things that we're going to be doing as we start integrating Firebase into our app a little more, and this is going to involve creating two more pages, right? So, we're going to create a login page, which will allow users to log in who already have an account. And for users that don't have an account, we're going to create a create account page. So, what you're going to want to do is open up your file tree here and inside the pages directory, we're just going to create two more files.
- The first one is going to be called, login page dot JS, and the second page is going to be called, create account page dot JS, and we're not going to put anything in these yet. We're going to implement these a little later on, but in addition to these two pages, we're also going to want to create a custom hook that will make it much easier for us to find out what user is currently logged in, which is something that we're going to need to know in several of our applications, components, and pages.
- So, what we're going to do here is create a new folder called hooks and this is going to going to contain all of the custom hooks in our application. It's really only going to be one custom hook for now, and inside here we're going to create a hook called use user dot JS. Now, the idea of this custom hook is that inside a component we'll be able to say something like cons user equals use user and just have immediate access to that user object and see if the user's logged in. See what the user's ID is, see what their email is, et cetera.
- So, that's going to be the idea here, and this is something that we'll get to implementing later on as well. All right, so now that we have that custom hook created and we also have our login page and create account pages created, the next thing that we're going to do is just create a basic skeleton for these pages, all right? It's just going to be very similar to what we did with our applications pages, such as the homepage, where we just say welcome to the create account page, basically, and this will just make things easier later on and allow us to set up the routes for both of these pages.
- So, inside our create account page file what we're going to do is say const create account page, and this is just going to be a simple function component, and what it's going to do is just return an H1 heading that says create account, all right? And we're going to be adding the rest of this page underneath this a little later on. So, don't worry too much about it right now. And then, we'll say export default create account page.
- And once we've done that, we're just going to copy all of this code and go into our login page component and we'll just paste it there and change this, so that it's the login page. And for the H1 heading, we'll say, log in instead, and then, we'll say export default login page. Great, so we have our create account page and login page components created. So, the next thing that we're going to do is go into our app component, all right? So, we'll open up app JS and we're going to create new routes for both of those pages.
- So, let's say import login page from pages slash login page, and then, we'll import the create account page as well. We'll say create account page from pages slash create account page. And then, what we can do is underneath all of our other routes, we'll say route path equals slash login.
- And the element for this is just going to be the login page like so, and then, we'll have our create account page. For this one, we're going to say route path equals slash create account. And the element for this one is going to be the create account page, all right? So, let's just put that in there and close the tag and that should be all we need.
- So, let's test this out. Our React app should be running. So, what we can do now is open this up in a browser and we should be able to just put in local host 3000 slash login and see the login page. And then, we should be able to put in local host 3000 slash create account and see the create account page.
- And, obviously, both of these are just a simple heading for now, but very soon we're going to be adding much more functionality to these and allowing users to actually log in and create accounts with them. And that's what we have coming up next.

## 4 Build a login form

- Okay, now that we set up some of the basic groundwork for our login page, create account page, and custom hooks, the next thing that we're going to do is actually start implementing the login page. So let's open up the login page component, and that's going to be in pages, LoginPage.js. And implementing this page is going to be pretty straightforward.
- All we're going to have to do is add two basic inputs and obviously we'll need state variables to track those, and we're also going to have a button that will call the appropriate Firebase Auth method, and that's something that we'll see very shortly, so don't worry if you don't know what that method is. Cool, so, first things first, what we're going to need to do is add some state variables to our login page, so that we can keep track of the values in our inputs, very similar to what we did earlier with the add comment forms.
- So what we're going to do is say import, useState from 'react'. All right. And that's pretty much all we need to create the basic form, so inside our login page component now what we're going to do is create an email state and a password state, and those are going to keep track of the respective values in each input. So let's say const email and setEmail equals useState, and the initial value for this is going to be an empty string, and we're going to do something very similar for the password input, We're going to say const password and setPassword equals useState, and the initial value, for this one is going to be an empty string as well.
- Now, in addition to both the email and password states, we're also going to have a specific state variable that will keep track of any errors that occur while the user is trying to log in, right? So when we try and log in with Firebase if the user put in the wrong password, let's say, or if they entered in a username that's not an email, then we're going to want to display that error.
- So in order to do that, we're just going to have an error state variable, so we'll say const error and setError equals useState, and that's going to be an empty string as well. Cool, so now that we have these three state variables we should be able to create most of the interface for this login page. What we're going to do is inside a react fragment. All right, so we're not going to have a special surrounding div for this login page, we're going to keep this h1 Log In heading, and underneath that we're going to have our inputs. So we'll have two inputs, the first one will be the email input, so we'll come back to that in just a minute.
- The second one is going to be the password input, and that's obviously going to have type equal to password there for the type attribute, and we're also going to have a button underneath that, that will say, Log In, right? This will be the button that the user clicks when they've entered their information and want to log in. And lastly, underneath this login button we're going to have a link to the create account page, just in case the user doesn't have an account so that they can go over to that page and create their account. All right.
- So what that's going to look like, we're just going to import the link component from react-router-dom, alright? This is the same thing that we did when we created our nav bar. So let's say import Link, from react-router-dom, and then if we go back down here, we should be able to create a simple link that will take the user to the create account page by saying Link to, and the path here is going to be /create-account, right? That's the path that we gave to the route that we defined in our app component.
- And the text in here is going to be pretty straightforward, we're just going to say, Don't have an account? Create one here. Okay, and that will just be a simple link that the user can click to go to the create account page. Cool, so now that we have all of the basic elements in our login page, and actually there's one that we're missing and that's going to be the error, but we'll add that later on. The next thing that we're going to do is actually bind the values of these inputs to the values of the state variables.
- Now, this is something that we did earlier with our add comment form, so it's going to be a pretty straightforward process if you remember what that was like, or you could always open up the add comment form for reference as well. So what we're going to do is we're going to say placeholder, this will be the hint text that we display to the user, and for that, we're going to say Your email address, and then we're going to create the binding between this input and our state variables up here, by saying value equals email and onChange, whenever the user types something new into the input, we're going to say event setEmail to e.target.value.
- Again, this is the same thing that we did in our add comment form. So now that we have that input set up, the next thing that we're going to do is add our second input, and what this is going to look like, in addition to our type attribute, we're also going to pass a placeholder value and onChange attribute just like we did in the input above.
- So let's say placeholder and for our password, we're going to want to say something like Your password, and under that will create our binding by saying value equals password, and onChange equals event, setPassword to e.target.value, all right? So pretty straightforward and pretty much the same thing between both of these inputs. Awesome. So now that we have both of those inputs bound to the corresponding state variables, let's actually add this error in here, basically all that we're going to want to do, this error is just going to be an error string that we'll want to display to the user, and in order to do that underneath our h1 heading, we're just going to say if error exists, okay, and the way that we do this in react is just by saying error and then the double ampersand sign, then what we want to do is display a paragraph tag with a className of error, okay? That's just for styling purposes, that className, and then inside here we'll display the actual error message.
- So this here is only going to display our error if the error actually exists and has a value, and that's something that will happen as the result of actually trying to log the user in with the email and password. Cool, so at this point we have pretty much everything in our login page set up, except for the actual login process itself, right? Once the user enters in their email and password, and clicks on this button, that's when we're going to start using Firebase Auth to log the user in with those credentials. Now, in order to make this happen what we're going to need to do is up at the top of our login page, we're going to import two things from the Firebase Auth package and those are going to be a function called getAuth, and another function called signInWithEmailAndPassword, and perhaps you can guess what this second function does, it's name is pretty self-explanatory I think, and these are going to be imported from the firebase/auth package.
- This is just the auth section of the Firebase package that we installed earlier. Cool, so now that we have those two things what we're going to do is inside our login page component, we're just going to create a new function called logIn. and this is going to be a pretty straightforward function that our button down here will call when it gets clicked, okay? So inside here, all we need to do is call this signInWithEmailAndPassword function that we imported from Firebase, and we're going to call that with the email and password that the user entered, and that should be really all we need to do.
- So let's say await, signInWithEmailAndPassword, and the way that most of these Firebased functions work as you'll see is you need to pass a Firebase auth references as the first argument, and that's what this getAuth function is for, so in almost all of our functions you'll see getAuth called as the first argument to signInWithEmailAndPassword, and then the second and third arguments that we pass to this function are the email and password that the function is talking about, alright? So this function call here should successfully log in the user, provided of course that they've given us the right email and password, and if they haven't, what this function is going to do is throw an error.
- So what we'll want to do is wrap this in a try catch block, and inside the catch block we're just going to take whatever error was generated and set this error state to that value. You'll see what that looks like in just a minute. So let's just say, try and catch error, and then if there was an error we'll just say setError to e.message, alright? And that will just take the error message, which is a string, and set this error state to that string. So the last thing that we're going to want to do now, now that we're logging in the user with their email and password, if everything goes well, we're going to want to route the user to the homepage, or we could also route them to the articles page instead, I suppose, which might make a little bit more sense.
- So what we're going to do is in order to navigate programmatically in a React app, we need a custom hook from react-router-dom, and that custom hook is called useNavigate. Now you might be familiar with a react-router-dom hook called useHistory from an older version of react-router-dom, and useNavigate is a new hook that replaces that, right? So it makes it very easy to navigate programmatically just by calling a function. So the way that we use this hook, inside our login page, is we're going to say const navigate equals useNavigate, and then all we have to do is call navigate with the path that we want to send the user to.
- So if we want to send the user to the articles list page, we can just say navigate /articles, and that will send the user to the articles page once they log in. Cool, so that's our login function. The last thing that we have to do here now is actually call this function when the user clicks the login button, and in order to make that happen all we need to do is say onClick equals logIn. And that should be all we need to do for our login page, so let's test this thing out, and we can do that just by going over to our application.
- And it looks like we have an error here, and that's just because we used the awake keyword without adding async to this function. So, that's a pretty easy fix, we should just be able to go back to here and add async to our login function here, and if we go back to our browser now, we should see that our create account page is showing, that's not what we want to see though, we want to see our login page.
- So if we enter login up here at the top of the browser and hit enter, we should see our login page displayed rather nicely. Okay, so nothing is going to happen at this point if we enter in our email address and password, and that's something that we're going to have to take a look at next, alright? At some point we're going to have to implement that useUser custom hook that we created the file for earlier, that will allow our components to know when a user logs in and change the app accordingly.

## 5 Creating a custom auth hook

- All right, so now that users can log into our application through the login page. The next thing that we're going to need to do is modify our article page so that it can adjust based on whether a user is logged in or not. Now, to give you an idea of what this is going to look like, inside our article page, remember that we're displaying both this Upvote section which allows a user to up vote an article, and we're also displaying this AddCommentForm.
- Now, we're only going to want to display both of those if the user is logged in. Because we're only going to want users to be able to up vote articles once. And we're only going to want users to be able to add comments if they're logged in. All right, so basically what we're going to need in this article page component, is a way to know at any given moment whether the user is logged in or not. And that's where this useUser custom hook comes in.
- So what this useUser custom hook is going to do, is allow our components to get immediate access to the currently logged in user. And if the user isn't currently logged in, then they'll be able to know by that fact that the user just won't exist. You'll see what this looks like in just a minute. But basically, in order to implement this custom hook, what we're going to do is we're going to say const useUser.
- And custom hooks and React are just functions that have hooks inside of them. And then what we're going to do is import the useState and useEffect hooks from React. And we're going to use these to store the current user state. And we're also going to keep track of whether or not we've already loaded the user. So what this is going to look like, is we're going to say const user and setUser equals useState.
- And the initial value for this is going to be null because when we're still figuring out whether or not the user's logged in, the value of the user is just going to be null. And underneath that, we're going to say, const isLoading and setIsLoading. And the initial value for this is going to be true. So in other words, when a component like our article page here uses useUser, the initial value of isLoading is going to be true and the initial value of user is going to be null. And this will allow us to know whether we've already determined if the user is logged in or not. And if so, what the user's data actually is. All right? So that's what these two state variables are going to allow us to do. Now, in order to actually know what the current user is, in Firebase what we need to do is subscribe using a function called onAuthStateChanged which we can import from the Firebase auth package.
- So let's say import, and we're going to import both getAuth. We're going to need this just like we needed it in the login page. And then the other function here that we need is onAuthStateChanged. Now, the way that this onAuthStateChanged function works, and by the way, both of these are imported from Firebase/auth, but the way that this onAuthStateChanged function works, is we can call it and we can pass a callback to it.
- And basically whenever the user changes their auth state either by logging in, logging out, or creating an account, the callback function that we pass to it will be called. So here's what that looks like. We're going to have to say useEffect. And inside this useEffect callback, we're going to say const unsubscribe. I'll describe what this unsubscribe thing is in just a minute. And we're going to say equals onAuthStateChanged. And the first argument to this, just like we saw with our login page, is going to be getAuth.
- And the second argument is going to be the callback function that will be called whenever the user logs in or logs out. So for this, we're going to say user. That will be the current user. And if the user isn't logged in, the value of this will be null. That's why we set the initial value up here to null. And then inside here all we're going to do is say setUser to user and setIsLoading to false.
- So let's talk a little bit about what's going on here inside this onAuthStateChanged callback. So user, this is either going to be a Firebase user object or it's going to be null. And if it's a Firebase user object, that'll mean that the user is logged in. If it's null, that'll mean the user is not logged in. And that's what our different components such as our article page will be able to look at. Now, as far as loading, in order to know whether this user state is null just because we haven't loaded the user yet. Or if the state is null because our user isn't logged in, we need to keep track of whether or not we've already loaded it. And that's what this state variable here is for now.
- As far as this unsubscribe thing goes, this is a function that are onAuthStateChanged function returns that will allow us to cancel that subscription and avoid memory leaks. So what we're going to want to do here is return unsubscribe. And basically what this will do in React is call this function when the component that's using this useUser hook, is removed from the dom. So if the user navigates away from the page, let's say. And last but not least, what we're going to do, is pass the second argument to useEffect which is going to be an empty array. Which will make sure that we only subscribe to auth state changes when the component first calls this useUser hook.
- So it won't get called every time the component updates. And that's pretty much it. So now all we have to do is return both these states, user and isLoading, so that the component can access them. And what that's going to look like, we're just going to say return user and isLoading and that's it. So let's just export our useUser custom hook by saying export default useUser. And we should be able to use this thing inside our article page now.
- So what we're going to do is say import useUser from hooks useUser, and then down here underneath, where we get our articleInfo and articleId, we're going to say const user and isLoading equals useUser. And now we have access to whether or not the user is logged in and we can use that to hide certain things down in our JSX. So what we were talking about before, is that if the user isn't logged in, instead of displaying this Upvote button, we're going to want to display some sort of button that says log in to Upvote. And down here for our AddCommentForm, we're going to want to hide this comment form if the user isn't logged in.
- And display a button instead that says something like login if you want to add a comment. So all we need to do for this is actually quite simple now that we have our custom hook. We're just going to say, if the user exists, then we'll want to display the original button because that means that the user is logged in. Otherwise, we're going to want to display a different button that will say something like Log in to upvote. And we'll have to link this button later on so that it actually takes the user to the login page. Okay.
- And if we go down here to our AddCommentForm, what we're going to do is the same kind of thing. We're just going to check to see if the user exists. If the user does exist, we're going to say AddCommentForm. Otherwise, what we're going to do is display a button that says, Log in to add a comment. And that's pretty much all we need to do. So let's test this thing out and we can do that by going back to our browser.
- And if we take a look at the articles page, we should see that it says, Log in to upvote and Log to add comment. And you'll notice that the up votes are not here and the comments aren't here. That's just because we don't currently have the backend running. But then if we go to our login page here.
- So if we go to localhost3000/login and enter in the email address that we created earlier. For me, it was shaun@gmail.com and the password was A,B,C, 1,2,3 exclamation point. If we click log in now, what we should see is that if we go back to an article it now has the Upvote button here and the add a comment form down here displayed for us. So in other words, our article page is successfully changing out these components depending on whether the user is logged in or not. So the next thing that we're going to want to do of course, is allow users to create an account if they don't already have an account.

## 6 Build a create-account page

- All right. So now that we've added a custom hook for keeping track of our users off state and we've added a little bit of logic to our article page to change the structure of the page depending on whether the user is logged in or not. The next thing that we're going to do is allow users that don't have an account yet to create an account by going into the create account page and implementing it.
- So let's open up our create account page. And the good news here is that a lot of this is going to be pretty repetitive from the login page. So if you want what you can actually do is copy a lot of this code and I'm just going to copy the top two imports here use state link and use navigate. We're going to paste those up here in the create account page. Like, so, and then we're going to copy the state variables here.
- So email, password, and error, and we're going to paste those in our create account page as well. And actually we're going to add one more state variable and that's going to be for the confirmed password field, right? So create account pages usually have that third field that wants the user to enter in their password again just to make sure that the user has entered in the password that they think they're entering.
- So what we're going to do here is just say, 'const' confirm password is what we'll call this state variable. And then we'll say set confirm password and this is going to be equal to use state. And the initial value will be an empty string. All right. So the create account page is just going to have three inputs instead of two, as the login page did. And besides that what we should be able to do is just copy the navigate login and return statements in our login page. And we're going to have to make a few changes to that but it won't be too bad.
- And we're just going to replace the return statement here in our create account page with that by pasting it. And now let's just sort of go through line by line and change things around. We'll skip over this login function for now. And in fact, I'll just delete that because our create account function is going to be a little bit different but as far as the JSX that we're returning, we're just going to want to change the heading to say, create account again we're going to display the error, just like we did before For the email address, that's going to be pretty much the same thing For the password, That's going to be the same as well.
- But what we're going to do is copy this field and paste it below. And this will be the confirm password field. So we'll say re-enter your password for the placeholder and then for the value, we'll say confirm password and for on change, we'll say set, confirm password. All right. And then down here for the button, we're going to say, Login we're going to change that to create account and we're going to change the name of this function that we're calling as well to create account.
- And then we're just going to sort of reverse this link so that it goes back to the login page in case a user has found their way to the create account page and already has an account. So what we're going to do here is just change this to so that it says log in. And what we'll do is change the text inside here to something like already have an account. Log in here. And that will just do the same thing in reverse that we did on our login page that sent the user to the create account page. All right. So that's pretty much all we have to do for the JSX.
- So let's go up here and we're going to implement a special function for creating an account. Now, thanks to fire bases its actually going to be very straightforward. What we're going to do is just import two functions from fire base. The first one is going to be that 'getAuth' function that we've seen before, that just gives us a reference to the current fire base off object.
- And after that we're going to import another function called 'createUserWith'. email and password. All right. And again, from the name here you can probably tell what this is going to do more or less. All right. So now that we have that we're just going to say from 'firebase/auth' and these two functions should allow us to very easily create an account using the email and password that our user has entered. Okay. So let's create an internal function inside our create account page. We're going to say const create account and this is going to be an asynchronous function, of course. So inside here, what we're going to do is say try.
- And the first thing that we'll do is check to make sure that the user's password and confirm password that they entered match. If not, that means that the user has made some sort of typo in either their password or confirm password and needs to just re-enter those. So what we're going to do is just say, if password does not equal confirm password, then what we want to do is say set error. And we want to set the error to something like password and confirm password do not match. And we'll just say return here so that it doesn't continue on. All right.
- Now, if the password and confirm password do match then what we're going to want to do is use this create user with email and password function that we imported from fire base auth. And basically all we need to do is call that with the email and password state. So what we're going to do is just say, await create user with email and password. We're going to call that with the three normal arguments that you might expect.
- The first one's going to be the getAuth function which gives a reference to fire base auth. And then the second and third one are going to be email and password and that's it. So at this point we should have a new user. And what we're going to do is navigate them - Just like we did in our login page to the article's list page where they can start reading articles, upvoting articles, commenting on articles, et cetera.
- So to do that, we just need to say navigate and we're going to send them to /articles again just like we did in the login page. Now, if something goes wrong, right? If the user enters in something that isn't an email for the email address, for example, or I don't know if their password isn't valid for some reason then an error is going to be thrown from this create user with email and password function.
- And all we're going to want to do here is catch that error. And we'll set the error state up here to the error message that was given to us. All right. So that's just going to look like this. We'll say set error to 'e.message'. And that should be all we need to do for our create account page. So let's test this thing out. And what we're going to do is go back to our app in our browser. We're going to open up the create account page by typing in create account and hitting enter. And oops, we get the 4 0 4 page because this should be local host 3000 slash create account not slash articles slash create account. So here we have our lovely create account page.
- So let's try entering in a new email address. We'll say Shaun2@gmail.com for the password. We'll say something like 'ABC123!' again same thing for the re-enter password. And actually let's just enter something a little bit different for the confirmed password, just so we can make sure that that piece of functionality works. So if we click create account now, sure enough we'll see this little error message that says password and confirm password do not match. If we now make them match and click the create account button again we should see that we get logged in. And just like when we use the login page, the upvote button and add comment, form our available to us.

## 7 Adding Firebase Auth to Node.js

- Okay. So at this point we've done pretty much all we can do on our front end to add firebase off until we've actually added firebase off to our back end as well. So, that's the next thing that we're going to take a look at is how to actually incorporate firebase off into our node JS server so that we can do things like make sure that users can't up vote an article more than once and make sure that users can only add comments if they're logged in, things like that. Okay. So, here's what this is going to look like.
- We're going to start off by going back to the fire base console here. And if you're still on this screen where we copied and pasted our code into our react app you can just click continue to console. And what we're going to need to do is generate some credentials that our server can use in order to interact with fire base off on a higher level. All right, this will allow us to do things like verify user's off tokens.
- So, what you're going to want to do is click on this little gear button and go to project settings. And once you're there you're going to go over to service accounts. And basically what we're going to need to do here is generate a private key that our server will be able to use. So thankfully, there's a button down here for just that purpose. And if you click on it, and then click "generate key" on the little module that comes up you're going to see that that will download a new key that you can use in order to connect to firebase off from your server. All right? So what you're going to want to do is take this key file and be very, very careful with it because it gives whoever has it permission to make changes to your firebase off project.
- So, this is something that you want to keep very, very safe. You don't want to publish it to GitHub by accident for example. And what you're going to want to do is move that into your project. All right? So, what I've already done is in my backend folder I've renamed that file that I downloaded to credentials.json You're going to want to do that same thing as well. And it's now inside the backend route directory. Okay, so now that we have this. And by the way, feel free to take a look at it just on your own. I'm not going to show you here because this is very sensitive credentials, but it's basically just a json object that contains some admin level credentials that our server will be able to use.
- So, what we're going to want to do, well, the first thing you'll want to do, actually, in order to make sure that this doesn't get committed to GitHub by accident is you're going to want to create a Git ignore file if you haven't already. And in there, along with things like node_modules, which you never want to commit and Mongo-DB-data, which is our database data that we also don't want to commit. You're going to want to add the credentials.json file and save that there.
- And what you should see is that that will turn a shade of gray in visual studio code indicating that it won't be committed to GitHub by accident. Okay, so now that we've done that the next thing that we're going to do is open up our server.js file and have our server load those credentials and use them to connect to firebase off, right? This is similar to what we did on our front end, but the server is going to have higher permissions since we control the server code, unlike our front end code which anybody can make changes to once they receive it on their browser.
- So before we do that, though, we're going to need to install the backend equivalent of the firebase package that we installed in the front end. And that package is called firebase admin. So what you're going to want to do is change directories into your backend by saying CD my-blog-backend. And then once you're in here, you're going to say, **NPM install firebase-admin**, right? That's the package name here. And once we've done that, we should be able to import that.
- And along with that we're going to import the credentials.json file and use that to set up our firebase admin package. So, what this is all going to look like we're going to start off by saying **import fs from 'fs'**. This is what we're going to use to load our credentials.json file. And under that we're going to say **import admin from firebase admin**. Okay? And then down below here, but above where we actually create our express app is where we're going to set up our firebase admin package on our node server and what that's going to look like, we'll start off by loading the credentials.json package. And that's going to look like this. We'll say const credentials = JSON.parse. And then inside here we just need to say fs.readFileSync, right? So we're synchronously loading that file which is normally not something that you want to do but since this is something that happens before we even start our server, it should be just fine.
- And we're going to want to load that file credentials .json, okay? And this will actually be../credentials.json since it's in the directory above our server.JS file. Okay, so now that we have our credentials loaded the next thing that we're going to want to do is use them to initialize this firebase admin package on our server and connect it to our firebase project and what that's going to look like, we just need to say admin.initializeApp. And this is going to take a configuration object which will be called credential.
- And the value for that is going to be admin.credential.cert And we're going to pass the credentials that we loaded as an argument to this. Okay? So don't worry too much about what's going on here. And all of the particular details, all that we're doing is telling the firebase admin package what credentials to use in order to connect to our project. It's basically very similar to what we did on the front end. Awesome, so at this point we have firebase admin added to our back end and we also have credentials that will allow it, as you'll see, to verify users that make requests to our servers. So the next thing that we're going to want to do is make sure that users can only up vote articles once. We'll see how to do that next. And we'll also see how to make sure that only users that are logged in can add comments to an article.

## 8 Protecting endpoints using auth-tokens

- Okay. So now that we've added firebase auth to both our front end and our back end it's time to see how to protect our backend endpoints so that users can't do things like add multiple upvotes or add comments without being logged in. So in both of these cases what we're going to need to do is protect our endpoints by basically checking to see whether the client that made the request was logged in or not. Now, the way that we're going to do that as you'll see is if we make a request from inside let's say our article page, in addition to just making our regular request with Axios, we're are also going to need to include something called an authtoken along with this request.
- Right now, the authtoken is basically just how the front end proves that the user is logged in and that they are who they say they are. So, you know, if you're not familiar with authtokens don't worry too much about it. Just know that these are what we need in order to implement this kind of functionality. So we'll get to the front end functionality a little bit later but first let's do our server. Essentially, what we're going to want to do is use the authtoken that's going to be included in every request coming from our front end, in order to load information about that user from firebase. All right? So what this is going to allow us to do is get things like the user's ID, the user's email, et cetera.
- So what this is going to look like we're going to be using the firebase-admin package for this. And what we're going to do is before we define any of our route handlers down here we're going to use something called express middleware to automatically load the user's information whenever we receive a request. All right? So middleware is basically just what we did with things like where we added express.json, which as we saw allowed us to get the request.body whenever the client side sent extra information along with their request. And we're going to do the same kind of thing in order to add a request.userproperty whenever the client side includes some credentials, right? Like an authtoken.
- So here's what this is going to look like. What we're going to do is say app.use. And in order to add middleware to an express app we basically just need to pass a function that takes the same request and response arguments as our handlers down here. But additionally, it will also need to take a next callback function. Now what that next function does, we simply need to call that when we're done processing things in the middleware, and we want the program to go on to the actual route handlers below. All right. So here's what this is going to look like. Inside our app.use middleware, we're going to start off by getting the token that the client side included, right? This is going to be the authtoken and it's going to be in the headers. So what that means is all we need to do to get the authtoken is say, const {authtoken} = req.headers. And we'll see how to include this authtoken header a little later on from inside our article page and similar components.
- So now that we have the authtoken the next thing that we need to do is actually use fire-base auth. We're going to use this admin thing that we set up before to actually take that authtoken and load the corresponding firebase user for that token. And this is actually a pretty straightforward thing to do. We just need to say const user = await admin.auth, all right, and that's a function that we need to call, .verifyIdtoken, and we're just going to pass that authtoken as an argument. Okay, so this is going to basically verify that this authtoken is valid and load the corresponding user for that authtoken. So if we want to set that on req.user now, all we need to do is say req.user = user.
- And we can even cut out a line there by removing that and just saying request.user right there. Okay? Now, since we're using the await keyword here we're going to need to change this to async. And there's also a possibility that this authtoken won't have been included with the request headers, right? If the user isn't logged in then we're not going to be including the authtoken along with the request, we're just going to want to load the basic article info and that's about it.
- The user won't be able to do things like upvote an article as you'll see. So what we're going to need to do is say if there is an authtoken, right, if (authtoken) then what we're going to do is try and verify that authtoken and load the corresponding user. And if that doesn't go well and there is a possibility that this will throw an error so we should wrap this in a try catch block. If that doesn't go well what we're going to want to do is catch the error and just send back a status code saying that something is wrong, right? Usually this will mean that the user included an invalid authtoken or is trying to hack the server. So we'll just send back a status of 400 indicating that the request was bad. Awesome. And that's all we need to do there.
- So in order to make sure that the program execution moves on to the actual route handlers below we'll just need to call the next callback function that we have up here. Okay. So that's how we load the user automatically from the authtoken that they've included with their headers. So the next thing that we're going to do is go through each of these route handlers that we've created before and incorporate the fact that we now know whoever user that's making a request is. All right. So for the first endpoint where we just send back data about an article to the client side, this one doesn't require a whole lot of protection, right? Because all clients should be able to access this data regardless of whether they're logged in or not.
- However, we will want to include a little piece of data with the data that we're sending back here, right? Where we say res.json(article) that indicates whether or not the user is allowed to upvote that article in the first place, right? And as you'll see later on, what we're going to do is on the front end, we'll use this piece of information to change the text on the upvote button so that it says something like already upvoted, all right? And it won't allow the user to click it again, basically. So in order to do this it's actually pretty straightforward. We're just going to need to get the ID from the user that we loaded up here, right? And since we've added that to req.user we can now access req.user down inside these request handlers.
- So what we're going to do is just say const, and the ID property on firebase users is actually called UID. So we'll have to get that property like so and say equals req.user. And then what we're going to do is after we've loaded the article we're going to check to see whether or not this user with this ID has already upvoted this article. Now, the way that we're going to do this is by adding an extra property to our articles in MongoDB. That will basically just be an array containing all of the IDs of users that have upvoted the article in the past. So what this is going to look like, we're going to say const upvoteIds is what we'll call the property. All right, that'll be the IDs again of the users who have already up uploaded the article. And we're going to say = article.upvoteIds.
- And since there's a chance that that property won't exist on these articles, since it's not currently in our database we're going to want to add a default value of an empty array to that. Okay. So now the way that we tell whether or not this user has already upvoted this article and therefore whether or not they're allowed to upvote the article again is simply by checking whether or not this user's ID is going to be in this upvote IDs property. And to do that, we just say, article.canUpvote.
- So we're adding a property to this article we're sending back that the front end will be able to use. And then we'll say = uid and we'll make sure that that exists first of all. And then we'll say and upvoteIds does not include the user ID. All right. So in other words, we're just checking to make sure that the user's ID isn't already in the upvoteIds property of our article and setting that property on the data we're sending back to the client side. Cool. So that's all we have to do on our get end point.

## 9 Protecting the upvote and comment endpoints

- The next two endpoints are going to be a little bit trickier, I believe. So, first of all, let's take a look at how to refactor this up vote endpoint so that we make sure that only users who haven't up-voted the article before can do so. Well, first of all, one thing that we should notice is that the up vote endpoint and the comments endpoint are both going to have the same initial criteria. And that is, if the user isn't already logged in we don't want the user to be able to make requests to either of these endpoints.
- So, what we can actually do is add another piece of middleware right above these two routes that will only apply to these two routes. And that's going to look like this. We're just going to say app dot use. And then we're going to say request response and next. And for the body of this we're going to say, if request dot user, right? In other words, if the user exists and has included the off token with their request then we'll just call next and allow them to go on to the following request handlers.
- Otherwise, we're going to want to send back an error status code by saying, else response dot send status. And the error code that we'll use here is 4, 0, 1, indicating that the user isn't allowed to access that resource. Okay, and that will prevent the user from making requests to either of these endpoints down here if they're not logged in. So, now that we've verified that, we can simply go into our up vote endpoint and we're going to want to check the same basic criteria that we did up here in our load article endpoint, right? We're just going to want to load the article and make sure that the user's ID isn't already in the up vote IDs array.
- So, we can actually just copy a lot of this. What we'll do is just copy these four lines here and then we'll go down into our up vote endpoint and above where we actually update our article. Because we want to make sure that the user hasn't already up-voted it before we actually make that change in the database. We're going to paste all of our lines of code. Okay, so the only changes that we have to make here now are once we've verified that the article exists and we've gotten the up vote IDs, we're just going to say const can up vote because we're not going to need to send this back to the client side. And then we're going to say, if can up vote and only then if the user is allowed to up vote, will we actually make changes to the database here.
- So, what I'm going to do is just copy this, paste it inside that if statement. And in addition to incrementing the up votes, now we're also going to want to add the users' UID property to the articles up vote IDs property that we're referencing right here. All right. So, what that's going to look like, we're just going to say dollar sign push. All right. This is the way that we add elements to arrays in MongoDB. And we're just going to say that we want to push onto the up vote IDs property, the user's ID, which we'll have to get up here.
- So we'll just say const UID equals request dot user. All right. So, that should take care of everything for us. So, let's just adjust the indentation down here. All right. We're just going to indent these things and actually we don't need this, if statement anymore we can just remove that. And we'll change this article here to updated article and then we'll send back the updated article to the client side. Okay. So, that's all we need to do for our up votes. The last thing we need to do is change our comments endpoint just a little bit.
- So, what we're going to do in our comments endpoint is make sure that the posted by property is equal to the user's email, right? When the user logs in they're obviously going to need their email address. So, instead of just allowing them to specify that by themselves and put in basically whatever they want we're just going to use the user's email. Now, the way that we do that is we're going to just remove the posted by property from the request dot body. And then down here, we'll say const and get the user's email by saying equals request dot user. All right.
- So, this fire base user object has an email property. That's basically just the email that the user signed up with. All right. So, now that we have that email, all we need to do is change this posted by property that we're inserting into our database and that's going to be equal to the user's email address, like so. Okay, and then we're just going to send back the updated article to the user and that's pretty much all we need to do. So, the last thing that we're going to need to do here is go into our article page and some of the components that it uses and make sure that they include this off token header that lets our server know who's who.

## 10 Making requests with auth tokens

- So now that we've added route protection to all of the routes on our server, the last thing that we're going to need to do is actually add the auth token that we're referring to in our middleware here, to all of the requests that we make from our article page, right? And this will be how our client proves that the user is logged in to our server.
- So what we're going to do is open up our article page and basically everywhere that we make a request using axios, we're going to have to include a header with the users auth token. Now, the good news is that since we've created this 'useUser' custom hook and have access to the user directly it's going to be pretty straightforward to do this. So to start off, let's change our load article info request so that it includes the header. This will be a good way to kind of get our feet wet with this.
- So first things first in order to get the user's auth token from this user object, all we need to do is say const token equals await user.getIdtoken. All right, now, in this case we're only going to want to send the token along with this request if the user is actually logged in and exists, right. As we've seen, there's a chance that the user object will be null. So we're also going to want to make sure that the user exists by saying user and await user.getIdtoken, Okay? So now that we have the token, we're just going to include that with our request by saying headers, all right, this is how we add headers to an axios.get request.
- It's going to be a little different for post and put requests as you'll see. And then we're going to say authtoken and we'll set that equal to the token that we just got. Okay, so that should successfully get the token from the user and include that in our headers. And we can actually verify this by starting our frontend. All right. So let's open up our frontend and we'll just restart that here by saying NPM run start and we'll open up another terminal as well. And start our backend. Here we go by changing directories into my blog backend and saying, NPM run dev. There. And oops, it looks like our backend. Isn't quite working because the 'credentials.json' isn't being loaded correctly.
- So all we should need to do here is change the path that we're using in our server to load our 'credentials.json' We're just going to change that to './credentials.json' And what we should see now is our server is successfully connected to the database and listening on port 8,000. Okay. So let's go back to our frontend here In our browser and make sure that it's working. Let's just open up one of our articles here like the fastest way to learn, React. And it looks like that's not quite working either. And that's just because we got an error from our server saying that request.user is not defined. Now, in order to fix this all we need to do do is provide a default value for request.user here. If an off token wasn't included, right? If a user isn't logged in and still wants to make this request.
- So all we need to do for that is just say request.user = request.user or if that doesn't exist an empty object and that should fix that for us, hopefully. And actually another thing that we need to do here is in order to stop this next function from being called if there's an error we're going to say return 'response.sendStatus'. All right, you'll notice that you get another error. If you don't do that that is actually very hard to figure out, right? It's an error that says something like cannot set headers after sending a request or something like that. And there actually is going to be one more error two that we have to address. And that is in our article page.
- Currently, if we don't have a user our token is just going to be the string null. Now that's a little bit inconvenient but that's just something that Axios does. Right, If you were to go into here and log out the type of this off token, if our user isn't logged in you would see that it was equal to the string null which means that this if statement would still execute kind of inconvenient but that's the way it is. So all we need to do for that is just change the logic slightly in our article page so that it says const headers equals, And then we'll check to see if the token exists.
- And if the token does exist, we'll say authtoken : token otherwise we're just going to have the headers be an empty object, like, so, and then we'll just have to include the headers like this instead. Okay. So that should fix any errors that you were seeing. So let's try one more time to refresh our application and Nope, it looks like there's still one more error and that is in upvote IDs. We typed the wrong function. This should be includes with an S. So hopefully this is a good lesson in troubleshooting for you because you know when we're creating fairly complex servers like we've done here, that sort of thing can happen.
- So let's head down to our articles and we're just going to say upvote IDs dot includes. And I believe we need that same thing down here in our upvote endpoint since we copied and pasted it. And let's try this again. If we go back and refresh our browser. Sure enough, we see that we finally have our upvotes and our comments. All right. So we've seen how to add the authtoken to one of the requests that our article page is making. Pretty much all we need to do from this point on is the same thing, but with our other requests. So the first thing that we're going to do is change our add upvote function. And all we need to do here is copy this code that we had up at the top, all right, for our token and headers and paste that in here.
- And then we're just going to need to include these headers in this response. Now since this is an axios.put request, we're going to need to Pass null as the second argument since in axios.put requests, that's the request body. And as the third argument we're going to pass our headers in an object like that. And that should automatically include that for our upvotes. So the last thing now we're going to do that same thing in our add comment form. And for this, we just need to paste those lines and we'll need the useUser custom hook that we made before. So we'll say import useUser, and then down here we'll say const user equals useUser. Like, so, And then we just need to add the headers by adding a third argument to axios.post that contains those headers.

## 11 Making interface adjustments for authenticated users

- Cool, so now that we've added these things to our front end we should be able to do all of the same things as before if our user is logged in. So, what we're going to do is go back here and try and upvote. So, if we click upvote, we should be able to upvote once, and then, if we click it again, we won't be able to do it anymore, right? Because our server isn't letting us. What's happening is when we click this button more the server is seeing that this user's ID is already on this article under upvotes and it won't let the user do anything. Now, as far as the add comment form, there actually is one more thing that we need to change about this, and that is, we just need to remove this name input since we're just going to be automatically adding the user's email to the comments.
- So, if we go back to here, what we're going to do in our add comment form is just remove that input. We can remove the label and everything, and what we can actually do is have a paragraph tag that says something like, you are posting as, and then we'll include the user's email by simply saying user.email, and we'll also want to check to make sure that the user exists here. So, we'll just add user and you are posting as user.email.
- So, if we go back here now, we'll see that it says, you are posting as shaun2@gmail.com. Remember, that that's who we're logged in as currently. And for the comment, let's actually just remove that label from our text area here and adjust the indentation, and that should be all we need to do. So, now, our comment form is quite different and we should be able to add a comment now just by saying, does this work? And if we click add comment, we should see that there's a new comment down here at the bottom with the user's email automatically added to the posted by property. All right, so our front end is successfully adding this off token to all of its requests that it's making.
- So, the last thing that we're going to do here is make it so that this upvote button changes depending on whether or not the user is able to upvote the article. All right, so if we go back to our article page, what we're going to do is since our article info now includes this can upvote property that we're getting from our load article endpoint here, right? Remember, we're adding that here.
- We're going to just add that to the default property and we'll say can upvote, and that will be false by default. And then, underneath that we can stay const can upvote, and we're just going to get that from the article info, so that we can use it down below. Okay, so now that we know whether the user can upvote the article or not, we just have to go down to the upvote button right here, and what we'll do is we'll change the text of the upvote button depending on whether or not the user can up vote it. So, all we have to do here is say, can upvote, and if the user can upvote, we'll say upvote. Otherwise, we'll say, already upvoted. And that's it.
- Now, one last thing here in order to make sure that that can upvote property is set correctly is we're only going to want to load the article info once we're done figuring out whether or not the user is logged in, all right? So, in order to do this, all we need to do is say, if is loading and then we'll say load article info, and then, we're going to want to add both is loading and user as dependencies for this use effect hook, all right? That'll just make sure everything happens at the right time.
- So, if we go back and take a look at our app now, we'll see that sure enough this user has already upvoted the article, and what we'll see is if we log out, which we currently can't do. That's going to be a very simple thing to do. All we need to do for that is open up the nav bar and add a log out button. All right, so what we're going to do is underneath the unordered list we're going to add a div with the class name of nav right. All right, that's just for styling purposes, of course. And inside here, what we're going to do is depending on whether or not the user's logged in, we're going to display either a log in button or a log out button, and this is made easy by our use user custom hook. So, let's say import use user from hooks use user.
- We're going to get the user by saying const user equals use user, like, so, and then down here, we'll say, if the user exists, we're going to display a button that says log out, all right? Otherwise, we're going to display a button that says, log in. Now, what these two buttons do, the first one, the log out button is just going to call Firebase Offs sign out functions. So, let's go up and import that. Just like with our other Firebase Off functions, we're going to say get Off, and then we're going to import the function itself, which is called sign out.
- And those are both imported from Firebase slash Off. And then, down here, what we'll do is when our log out button is clicked, we're going to define a function that says, sign out, and we just need to pass the Off reference to that function, and that will log the user out. And as far as logging in, when the user clicks on this button, we're just going to want to send them to the log in page. And we'll do that using the use navigate hook from React router Dom, which we've already seen. So, let's just say, use navigate, and if we go down here, we'll say const navigate equals use navigate. And then, for our log in button, we're just going to send the user to the log in page.
- So, we'll say on click equals and for this function here, we'll just say, navigate and send them to slash log in. And that's it. So, let's test this thing out. If we go back to our app now we should see that sure enough, we have this log out button here. If we click it, we'll see that immediately these buttons change, and it says log in to upvote and log in to add a comment. And if we click the log in button now, it will take us directly to the log in page. And if we enter in something like shaun@gmail.com and the password and click log in, that will take us to the article's list page where we can now upvote articles and add comments. And that pretty much completes adding Firebase Off to both our front end and back end. So, congratulations on adding authentication to this full stack app.
