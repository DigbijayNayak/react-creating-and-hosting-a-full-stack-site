# Hosting a Full-Stack React Application

## 1. Preparing an app for release

- All right, so at this point, our full stack app is pretty much finished, which means that we can move on to actually seeing how to release this app and host it somewhere on the internet, so that anyone can access it. So what we're going to be doing here is preparing our app for release, and this is going to involve a few things.
- The first thing that we're going to have to do is actually build our frontend here, and have it hosted by our backend, right? So, first of all, the way that we build our frontend is by changing directories into our frontend directory, in case you're not already there, and running the command npm run build.
- Now, what this will do is it'll take all of the developer friendly code that we've been working with so far and turn it into browser friendly code and basically all of that code is going to be put into this build folder that you just saw up here over here on the left. All right, so once this is done, what we're going to want to do is move this build folder into our backend, so that our node server can be the one that actually serves all of these files, all right? Currently, while we've been developing the frontend, it's just been Reacts built-in development server that's been hosting our app for us.
- But in production, we're going to need to actually have it hosted by our node server. So, what you're going to want to do is, copy this build folder and go into my-blog-backend and we're going to paste this folder inside here. Now, if you're using GitHub for your backend, you're probably going to want to add this build folder to your gitignore and to do that, you just need to go in here and add build and you should see that turn gray, which means that it won't get committed. Okay, so now that we've built our frontend and we've added it to our backend folder, what we're going to do is have our node server actually serve those files statically.
- So here's what that's going to look like. The first thing that we're going to need to do is tell express to use that build folder as a static folder. And to do that, we just need to say app.use express.static. And then for the path that we specify, we're going to say path.join, and then we're going to have double underscore directory name, and we're going to join that together with ../build. All right, now, because we added type module to our package .json file. This underscore underscore directory name thing, unfortunately won't work by default.
- So what we have to do, and this is a little bit of a pain, but up here at the top of our server, we just need to say import file to URL path, or file URL to path, rather. And then we're going to say const underscore underscore file name equals file URL to path import.meta.URL. And then under that, we're going to say, const underscore underscore directory name equals path.directory name and we're going to pass the file name to that. And additionally we also need to import the path package from no JS. So we'll say import path from path, and don't worry too much about all the details of what's going on here.
- Just know that what we're doing here is recreating the underscore underscore directory name thing that's available when the type is not equal to module. So anyway, this should work now. And the other thing that we're going to have to do is add a route handler specifically for when we receive a request that isn't to one of our API routes. So what this is going to look like is we're going to say app.get, and for the path here we're actually going to have to use a regular expression. Now, the reason for this what this regular expression is going to allow us to do is handle any request that doesn't go to one of our API routes, all right? So that's why we started all of these routes with slash API is so that it would give us an easy way to tell our API routes apart from when someone's using a browser and just trying to open up one of our pages that we're hosting now.
- So anyway, what this is going to look like and you're going to have to type this exactly. It's going to be slash caret symbol parentheses. And then inside here we're going to have question mark exclamation point. Yes, I'm serious about this. And then we're going to have back slash, forward slash API and then we're going to close those parentheses and say .plus/. All right, so this will basically just handle all the routes that don't start with API. That's all you need to know about that regular expression there.
- So now that we have that for the route handler we're just going to say request and response. And inside here we're just going to say response.send file path.join. And the path here is going to be underscore underscore directory name. And we're going to say ../build/index.html. So all that this is doing here is whenever a browser sends a request to our server, that isn't going to the API route, we're going to send back the index.html file, which will take care of loading our react script and rendering our react app, okay? So that's what's going on there and what we should be able to do now, excitingly enough, is run our server and be able to access our react app simply by sending a request to our server.
- All right, so what we can do is let's change directories into our backend. Write My blog backend. And if we run NPM run dev, now, what we should see is that our server is now listening. And now if we go into a browser and paste, local host, 8,000 and hit enter, we can now see our react app being rendered in our browser, even though the request that we sent was to our server, right? So the server's sending back the index.html file and that's taking care of loading our react script and rendering our app in the browser.
- All right, so let's just take a look around to make sure that everything is working and it looks like everything is still working. So the next thing that we're going to need to do is make a change to our server so that the run time we'll be able to tell it what port it should listen on. Right, this is going to be very important when we publish our server to some sort of hosting platform because usually hosting platforms like to be able to tell the server what port it should listen on.
- So what we're going to do for that is we're just going to say const port equals, and then we're going to take a look at process.environment .port. And this will just allow the hosting platform to specify the port that our app should listen on as an environment variable. Now, obviously in development mode we're just going to want that to be 8,000. So we'll provide a default value of 8,000 for that. And now we just need to go in here and replace 8,000 with port and the same thing here. We're going to say, server is listening on port and then we'll add the port number to the end of that.

  ```js
  import path from "path";

  import { fileURLToPath } from "url";
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);

  app.use(express.static(path.join(__dirname, "../build")));
  app.get(/^(?!\/api).+/, (req, res) => {
    res.sendFile(path.join(__dirname, "../build/index.html"));
  });

  const PORT = process.env.PORT || 8000;
  ```

## 2. Setting up hosting for MongoDB

- All right now, one more thing that we have to do here in order to get our app ready to publish is we have to actually host MongoDB somewhere else as well, right? Currently we're hosting MongoDB locally and for obvious reasons, once we're hosting our application on some sort of hosting platform we're not going to be able to access our local database. So what I'm going to recommend, there are obviously lots of different hosting platforms for MongoDB, but I've found that the free version of MongoDB's Atlas software is generally the easiest one to work with. So what you're going to want to do is search for MongoDB Atlas and you'll probably have to create an account by going this link https://www.mongodb.com/cloud/atlas/register.
- Hopefully you don't have to put in billing information but you might, just be assured that it's been free for me even though I've been using it for quite a while. And what you're going to want to do is once you get to this dashboard, you're going to create a new project. Now, I already have one called Full Stack React Course, that's just from when I was testing out the code for this course. So we're going to create a new project here and this is basically just going to allow us to set up a shared Mongo DB server that will be able to connect to just like we were able to connect to our local MongoDB instance. So, first of all, we need a name for our project. I'll just call mine Full Stack Blog Site and we'll click next.
- The next thing it's going to want is for us to add members and set permissions on this project. The only one you're going to need is your own email down here and then we're going to click create project. Okay, so once we've created the project we're going to click on build a database in the middle of the screen here presented very conspicuously for us and then we're going to select shared, all right? So this one says free, and again, for me so far, it's been free. Hopefully they keep it that way after I record this. And then the next thing that it's going to ask is where you want to host MongoDB. Now, this is going to depend on where you're at geographically, since I'm in the Eastern United States I'm going to leave North Virginia selected, but you may want to select one of these other ones here. So once you've selected the cluster that's closest to you, just click on create cluster and that should create a new database for you.
- But what it's going to ask you first is for a username and password that can be used to connect to this database, all right? So basically the username and password here are what we can use to set up our database both through the Mongo Shell and it's also what our node server is going to use as you'll see to connect to this database, right? This basically just prevents other people besides us from connecting to our database and messing things up. So what we're going to do, let's just create a username. We'll call it node-server and for the password, let's just click on autogenerate secure password and click copy so that we have a copy of that password.
- And then we'll click on create user which should add that user to our database. All right, so now that we have the username and password, what we're going to need to do is go back to our project and add both of those things to an environment file for our my-blog-backend. All right, so what we're going to do is create a new file and we're going to say .env, all right, so this will just contain environment variables for our project and then in here we're just going to add MONGO_USERNAME= and remember we called it node-server, and then we're going to add MONGO_PASSWORD which is going to be equal to the value that we copied from our browser. All right, so now that we have the username and password for MongoDB, what we're going to need to do is load those into our server file when it runs and we're going to need to connect to MongoDB with those credentials.
- So first things first, in order to automatically load environment variables from a .env file, I generally use the .env package, so let's install that. We're going to say, npm install dotenv, and hit enter and that should install that package for us. So once we've done that we should be able to just add the import up at the top here and say, import dotenv/config and that will automatically take those MONGO_USERNAME and MONGO_PASSWORD things that we added in our .env file and set them on process .env here. Okay, now what that means is we should be able to use those things to connect to our database.
- So let's open up our db.js file and instead of connecting to our local database here now, we're going to connect to the new database that we just created in MongoDB Atlas. And the good news is that there's actually a pretty easy way to do this if you go back to MongoDB Atlas, what you're going to want to do is click on database over here on the left and what that should do is bring up your database deployments, you're going to want to find the free cluster that we just created and click connect and that will give you some options for how to connect.
- Now, first of all, it's going to ask you where you should be able to connect from, and for security reasons it's probably best if you say, add your current IP address and just create specific IP addresses that are able to connect but what we're going to do is say, allow access from anywhere and say, add IP address, and then what we're going to do is click this choose a connection method button, and we're going to say connect your application. And this will give you the URL that you can use to connect to this MongoDB instance.
- So let's just copy this here and then we're going to go back to our code and replace MongoDB local host with what we had here. And then we'll just need to insert the MongoDB username and MongoDB password into this URL by changing this back ticks like so, and then we're just going to say, instead of node-server, ${process.env.MONGO_USERNAME} and for the password we're going to replace that with process.env.MONGO_PASSWORD. Okay, and that should allow us to connect to that MongoDB instance from our server. Now, in order for this to work nicely though, what we're going to need to actually do is insert some data into that Mongo database that we just created, right? Because currently only our local database has data in it.
- So what we're going to want to do is go back to the MongoDB Atlas interface and we'll click connect again, but this time, what we're going to do is select connect with the MongoDB Shell, all right? And all that this is going to do is it's going to give you some instructions for connecting to MongoDB with the command line. And the first thing is going to be installing the Mongo Shell, I already have that installed, so I don't need to run that command, but you might, and then what I'm going to do is copy this command and we can go back now to our terminal and I'm going to run that command in here and what it should do is ask for our passwords.
- So we're going to want to copy the password that we put inside the environment file, just going to copy this here and paste it there and hit enter, and we should see that the Mongo Shell comes up under here. Awesome, so at this point, we're into our Mongo database that we created on MongoDB Atlas which means that this database is theoretically accessible from anywhere by our server. So what we're going to do is the same kind of setup that we did when we set up our local database. The first thing we're going to do is say, use react-blog-db and hit enter. All right, so we're now in our react-blog-db.
- So now we just need to say db.articles.insertMany and what you're going to want to do here is copy and paste the array that we had from earlier which contains our starting article info. All right, now, if you don't have this laying around, fortunately, it's not very much to type out. So I would just recommend going ahead and doing that or you can always look on GitHub to see if you can find it in some of the old exercise files for earlier videos.
- So once you have that, we're going to hit enter and you should see acknowledged true insertedIds, and that basically means that we successfully inserted those into the database. So now what we should be able to do just to tie this all back together is exit the Mongo Shell which you can do by pressing control C twice and then we're going to run our back end by saying npm run dev and hitting enter. And what you should see is successfully connected to database, which means that we were able to connect to our remote database now and if we go back and take a look at our app and more importantly, if we take a look at our articles we should see that we're able now to upvote these articles which we can do by logging in first. All right, so we'll need to log in before we can do this.
- We'll just say shaun@gmail.com or whatever the email that you used in Firebase Auth was before, those emails are still going to be the same. And then we'll put in our password and click log in and we should successfully be logged in. And I'm noticing now that the already upvoted thing is not quite right, and the reason for that I believe is that this if statement should be if is not loading. So you just need to add the not sign to that and then unfortunately what we're going to need to do is rebuild our frontend and re-add it to our backend.
- So let's just go back to our frontend by saying cd my-blog and we'll run npm run build again, and then once that's built, we're going to copy and paste that over to our backend again. So let's just go into our backend and delete the build folder that's currently there, and then we'll go back into my-blog, copy the build folder and put that into my-blog-backend.
- So that's why it's important to make sure that you get these things right in development mode. So let's paste this now and we should be able now to run our backend again by saying cd my-blog-backend and we'll run it with npm run dev like so, and we should be able to see this in its correct format by refreshing the page and sure enough, we'll see upvote.
- And if we click on that upvote button now we'll see that it changes to already upvoted and adds one upvote to our article. All right, now we're also going to see that there are no comments here. So let's try adding a comment and we'll say, this is so amazing and click add a comment and sure enough, we should see that that comment has been added below and furthermore, if we try and refresh this we'll see that both of those things are persisted in our remote MongoDB database now. So everything is pretty much ready for us to release this application, so the next thing that we're going to take a look at how to do is release this app to Google Cloud.

## 3. Releasing a full-stack application

## 4. Shutting down a Google Cloud project
